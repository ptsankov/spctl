MODULE main

VAR
  state : {out, lob, cor, off, mr};
  visitor: boolean;
  owner: boolean;

ASSIGN
  init(state) := out;
  init(visitor) := {TRUE, FALSE};
  init(owner) := {TRUE, FALSE};

  next(visitor) := visitor;
  next(owner) := owner;
  next(state) := case
      state = out: {lob, cor, out};
      state = lob: {out, cor, lob};
      state = cor: {out, lob, off, mr, cor};
      state = off: {cor, off};
      state = mr: {cor, mr};
  esac;

DEFINE
  authz_lob_cor := TRUE | TRUE;
  authz_lob_out := TRUE | TRUE;
  authz_mr_cor := TRUE | TRUE;
  authz_cor_lob := TRUE | TRUE;
  authz_cor_mr := TRUE & visitor;
  authz_cor_off := owner & TRUE;
  authz_cor_out := TRUE | TRUE;
  authz_off_cor := TRUE | TRUE;
  authz_out_lob := TRUE | TRUE;
  authz_out_cor := !owner & !visitor;

TRANS
  ((state = out & !authz_out_lob) -> next(state) != lob) &
  ((state = out & !authz_out_cor) -> next(state) != cor) &
  ((state = lob & !authz_lob_out) -> next(state) != out) &
  ((state = lob & !authz_lob_cor) -> next(state) != cor) &
  ((state = cor & !authz_cor_out) -> next(state) != out) &
  ((state = cor & !authz_cor_lob) -> next(state) != lob) &
  ((state = cor & !authz_cor_off) -> next(state) != off) &
  ((state = cor & !authz_cor_mr) -> next(state) != mr) &
  ((state = off & !authz_off_cor) -> next(state) != cor) &
  ((state = mr & !authz_mr_cor) -> next(state) != mr);

SPEC
  ((owner & state = out) -> (EF state = off)) &
  ((visitor & state = out) -> (EF (state = mr))) &
  ((visitor & state = out) -> (!E[state != lob U state = mr])) &
  ((!owner & state = out) -> (!EF (state = off))) &
  (AG EF (state = out))
